(window["webpackJsonp"]=window["webpackJsonp"]||[]).push([["chunk-531a7aa0"],{1843:function(e,t,r){"use strict";r.r(t);var s=function(){var e=this,t=e.$createElement;e._self._c;return e._m(0)},a=[function(){var e=this,t=e.$createElement,s=e._self._c||t;return s("section",[s("h5",{attrs:{id:"translated-by-vincent-isambart"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#translated-by-vincent-isambart"}},[e._v("¶")]),e._v(" Translated by Vincent ISAMBART")]),s("h1",{attrs:{id:"chapter-2%3A-objects"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#chapter-2%3A-objects"}},[e._v("¶")]),e._v(" Chapter 2: Objects")]),s("h2",{attrs:{id:"structure-of-ruby-objects"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#structure-of-ruby-objects"}},[e._v("¶")]),e._v(" Structure of Ruby objects")]),s("h3",{attrs:{id:"guideline"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#guideline"}},[e._v("¶")]),e._v(" Guideline")]),s("p",[e._v("Starting from this chapter we will explore the "),s("code",{pre:!0},[e._v("ruby")]),e._v(" source code, starting by studying the declaration of objects structures.")]),s("p",[e._v("What are the required conditions to make sure objects can exist? Many explanations can be given but in reality there are three conditions that must be obeyed:")]),s("ul",[s("li",[e._v("Being able to differentiate itself from the rest (having an identity)")]),s("li",[e._v("Being able to reply to requests (methods)")]),s("li",[e._v("Keeping an internal state (instance variables)")])]),s("p",[e._v("In this chapter, we are going to confirm these three features one by one.")]),s("p",[e._v("The most interesting file in this quest will be "),s("code",{pre:!0},[e._v("ruby.h")]),e._v(", but we will also briefly look at other files such as "),s("code",{pre:!0},[e._v("object.c")]),e._v(", "),s("code",{pre:!0},[e._v("class.c")]),e._v(" or "),s("code",{pre:!0},[e._v("variable.c")]),e._v(".")]),s("h3",{attrs:{id:"structure-of-value-and-objects"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#structure-of-value-and-objects"}},[e._v("¶")]),e._v(" Structure of "),s("code",{pre:!0},[e._v("VALUE")]),e._v(" and objects")]),s("p",[e._v("In "),s("code",{pre:!0},[e._v("ruby")]),e._v(", the contents of an object is expressed by a "),s("code",{pre:!0},[e._v("C")]),e._v(" structure, always handled via a pointer. A different kind of structure is used for each class, but the pointer type will always be "),s("code",{pre:!0},[e._v("VALUE")]),e._v(" (figure 1).")]),s("p",[s("img",{attrs:{src:r("a283"),alt:"( and structure)"}})]),s("p",[e._v("Here is the definition of "),s("code",{pre:!0},[e._v("VALUE")]),e._v(":")]),s("p",[e._v("▼ "),s("code",{pre:!0},[e._v("VALUE")])]),s("pre",{pre:!0},[s("code",{pre:!0,attrs:{"v-pre":""}},[e._v("  71  typedef unsigned long VALUE;\n\n(ruby.h)\n")])]),s("p",[e._v("In practice, a "),s("code",{pre:!0},[e._v("VALUE")]),e._v(" must be casted to different types of structure pointer. Therefore if an "),s("code",{pre:!0},[e._v("unsigned long")]),e._v(" and a pointer have a different size, "),s("code",{pre:!0},[e._v("ruby")]),e._v(" will not work well. Strictly speaking, it will not work for pointer types bigger than "),s("code",{pre:!0},[e._v("sizeof(unsigned long)")]),e._v(". Fortunately, no recent machine feature this capability, even if some time ago there were quite a few of them.")]),s("p",[e._v("Several structures are available according to object classes:")]),s("p",[e._v("| "),s("code",{pre:!0},[e._v("struct RObject")]),e._v(" | all things for which none of the following applies | | "),s("code",{pre:!0},[e._v("struct RClass")]),e._v(" | class object | | "),s("code",{pre:!0},[e._v("struct RFloat")]),e._v(" | small numbers | | "),s("code",{pre:!0},[e._v("struct RString")]),e._v(" | string | | "),s("code",{pre:!0},[e._v("struct RArray")]),e._v(" | array | | "),s("code",{pre:!0},[e._v("struct RRegexp")]),e._v(" | regular expression | | "),s("code",{pre:!0},[e._v("struct RHash")]),e._v(" | hash table | | "),s("code",{pre:!0},[e._v("struct RFile")]),e._v(" | "),s("code",{pre:!0},[e._v("IO")]),e._v(", "),s("code",{pre:!0},[e._v("File")]),e._v(", "),s("code",{pre:!0},[e._v("Socket")]),e._v(", etc... | | "),s("code",{pre:!0},[e._v("struct RData")]),e._v(" | all the classes defined at C level, except the ones mentioned above | | "),s("code",{pre:!0},[e._v("struct RStruct")]),e._v(" | Ruby's "),s("code",{pre:!0},[e._v("Struct")]),e._v(" class | | "),s("code",{pre:!0},[e._v("struct RBignum")]),e._v(" | big integers |")]),s("p",[e._v("For example, for an string object, "),s("code",{pre:!0},[e._v("struct RString")]),e._v(" is used, so we will have something like the following.")]),s("p",[s("img",{attrs:{src:r("570c"),alt:"(String object)"}})]),s("p",[e._v("Let's look at the definition of a few object structures.")]),s("p",[e._v("▼ Examples of object structure")]),s("pre",{pre:!0},[s("code",{pre:!0,attrs:{"v-pre":""}},[e._v("      /* structure for ordinary objects */\n 295  struct RObject {\n 296      struct RBasic basic;\n 297      struct st_table *iv_tbl;\n 298  };\n\n      /* structure for strings (instance of String) */\n 314  struct RString {\n 315      struct RBasic basic;\n 316      long len;\n 317      char *ptr;\n 318      union {\n 319          long capa;\n 320          VALUE shared;\n 321      } aux;\n 322  };\n\n      /* structure for arrays (instance of Array) */\n 324  struct RArray {\n 325      struct RBasic basic;\n 326      long len;\n 327      union {\n 328          long capa;\n 329          VALUE shared;\n 330      } aux;\n 331      VALUE *ptr;\n 332  };\n\n(ruby.h)\n")])]),s("p",[e._v("Before looking at every one of them in detail, let's begin with something more general.")]),s("p",[e._v("First, as "),s("code",{pre:!0},[e._v("VALUE")]),e._v(" is defined as "),s("code",{pre:!0},[e._v("unsigned long")]),e._v(", it must be casted before being used. That's why "),s("code",{pre:!0},[e._v("Rxxxx()")]),e._v(" macros have been made for each object structure. For example, for "),s("code",{pre:!0},[e._v("struct RString")]),e._v(" there is "),s("code",{pre:!0},[e._v("RSTRING()")]),e._v(", for "),s("code",{pre:!0},[e._v("struct RArray")]),e._v(" there is "),s("code",{pre:!0},[e._v("RARRAY()")]),e._v(", etc... These macros are used like this:")]),s("pre",{pre:!0},[s("code",{pre:!0,attrs:{"v-pre":""}},[e._v("VALUE str = ....;\nVALUE arr = ....;\nRSTRING(str)->len;   /* ((struct RString*)str)->len */\nRARRAY(arr)->len;    /* ((struct RArray*)arr)->len */\n")])]),s("p",[e._v("Another important point to mention is that all object structures start with a member "),s("code",{pre:!0},[e._v("basic")]),e._v(" of type "),s("code",{pre:!0},[e._v("struct RBasic")]),e._v(". As a result, whatever the type of structure pointed by "),s("code",{pre:!0},[e._v("VALUE")]),e._v(", if you cast this "),s("code",{pre:!0},[e._v("VALUE")]),e._v(" to "),s("code",{pre:!0},[e._v("struct RBasic*")]),e._v(", you will be able to access the content of "),s("code",{pre:!0},[e._v("basic")]),e._v(".")]),s("p",[s("img",{attrs:{src:r("76ea"),alt:"()"}})]),s("p",[e._v("You guessed that "),s("code",{pre:!0},[e._v("struct RBasic")]),e._v(" has been designed to contain some important information shared by all object structures. The definition of "),s("code",{pre:!0},[e._v("struct RBasic")]),e._v(" is the following:")]),s("p",[e._v("▼ "),s("code",{pre:!0},[e._v("struct RBasic")])]),s("pre",{pre:!0},[s("code",{pre:!0,attrs:{"v-pre":""}},[e._v(" 290  struct RBasic {\n 291      unsigned long flags;\n 292      VALUE klass;\n 293  };\n\n(ruby.h)\n")])]),s("p",[s("code",{pre:!0},[e._v("flags")]),e._v(" are multipurpose flags, mostly used to register the structure type (for instance "),s("code",{pre:!0},[e._v("struct RObject")]),e._v("). The type flags are named "),s("code",{pre:!0},[e._v("T_xxxx")]),e._v(", and can be obtained from a "),s("code",{pre:!0},[e._v("VALUE")]),e._v(" using the macro "),s("code",{pre:!0},[e._v("TYPE()")]),e._v(". Here is an example:")]),s("pre",{pre:!0},[s("code",{pre:!0,attrs:{"v-pre":""}},[e._v("VALUE str;\nstr = rb_str_new();    /* creates a Ruby string (its structure is RString) */\nTYPE(str);             /* the return value is T_STRING */\n")])]),s("p",[e._v("The names of these "),s("code",{pre:!0},[e._v("T_xxxx")]),e._v(" flags are directly linked to the corresponding type name, like "),s("code",{pre:!0},[e._v("T_STRING")]),e._v(" for "),s("code",{pre:!0},[e._v("struct RString")]),e._v(" and "),s("code",{pre:!0},[e._v("T_ARRAY")]),e._v(" for "),s("code",{pre:!0},[e._v("struct RArray")]),e._v(".")]),s("p",[e._v("The other member of "),s("code",{pre:!0},[e._v("struct RBasic")]),e._v(", "),s("code",{pre:!0},[e._v("klass")]),e._v(", contains the class this object belongs to. As the "),s("code",{pre:!0},[e._v("klass")]),e._v(" member is of type "),s("code",{pre:!0},[e._v("VALUE")]),e._v(", what is stored is (a pointer to) a Ruby object. In short, it is a class object.")]),s("p",[s("img",{attrs:{src:r("f61d"),alt:"(object and class)"}})]),s("p",[e._v('The relation between an object and its class will be detailed in the "Methods" section of this chapter.')]),s("p",[e._v("By the way, the name of this member is not "),s("code",{pre:!0},[e._v("class")]),e._v(" to make sure it does not raise any conflict when the file is processed by a C++ compiler, as it is a reserved word.")]),s("h4",{attrs:{id:"about-structure-types"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#about-structure-types"}},[e._v("¶")]),e._v(" About structure types")]),s("p",[e._v("I said that the type of structure is stored in the "),s("code",{pre:!0},[e._v("flags")]),e._v(" member of "),s("code",{pre:!0},[e._v("struct Basic")]),e._v(". But why do we have to store the type of structure? It's to be able to handle all different types of structure via "),s("code",{pre:!0},[e._v("VALUE")]),e._v(". If you cast a pointer to a structure to "),s("code",{pre:!0},[e._v("VALUE")]),e._v(", as the type information does not remain, the compiler won't be able to help. Therefore we have to manage the type ourselves. That's the consequence of being able to handle all the structure types in a unified way.")]),s("p",[e._v("OK, but the used structure is defined by the class so why are the structure type and class are stored separately? Being able to find the structure type from the class should be enough. There are two reasons for not doing this.")]),s("p",[e._v("The first one is (I'm sorry for contradicting what I said before), in fact there are structures that do not have a "),s("code",{pre:!0},[e._v("struct RBasic")]),e._v(" (i.e. they have no "),s("code",{pre:!0},[e._v("klass")]),e._v(" member). For example "),s("code",{pre:!0},[e._v("struct RNode")]),e._v(" that will appear in the second part of the book. However, "),s("code",{pre:!0},[e._v("flags")]),e._v(" is guaranteed to be in the beginning members even in special structures like this. So if you put the type of structure in "),s("code",{pre:!0},[e._v("flags")]),e._v(", all the object structures can be differentiated in one unified way.")]),s("p",[e._v("The second reason is that there is no one-to-one correspondence between class and structure. For example, all the instances of classes defined at the Ruby level use "),s("code",{pre:!0},[e._v("struct RObject")]),e._v(", so finding a structure from a class would require to keep the correspondence between each class and structure. That's why it's easier and faster to put the information about the type in the structure.")]),s("h4",{attrs:{id:"the-use-of-basic.flags"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#the-use-of-basic.flags"}},[e._v("¶")]),e._v(" The use of "),s("code",{pre:!0},[e._v("basic.flags")])]),s("p",[e._v("As limiting myself to saying that "),s("code",{pre:!0},[e._v("basic.flags")]),e._v(" is used for different things including the type of structure makes me feel bad, here's a general illustration for it (figure 5). There is no need to understand everything right away, I just wanted to show its uses while it was bothering me.")]),s("p",[s("img",{attrs:{src:r("b6cb"),alt:"(Use of )"}})]),s("p",[e._v("When looking at the diagram, it looks like that 21 bits are not used on 32 bit machines. On these additional bits, the flags "),s("code",{pre:!0},[e._v("FL_USER0")]),e._v(" to "),s("code",{pre:!0},[e._v("FL_USER8")]),e._v(" are defined, and are used for a different purpose for each structure. In the diagram I also put "),s("code",{pre:!0},[e._v("FL_USER0")]),e._v(" ("),s("code",{pre:!0},[e._v("FL_SINGLETON")]),e._v(") as an example.")]),s("h3",{attrs:{id:"objects-embedded-in-value"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#objects-embedded-in-value"}},[e._v("¶")]),e._v(" Objects embedded in "),s("code",{pre:!0},[e._v("VALUE")])]),s("p",[e._v("As I said, "),s("code",{pre:!0},[e._v("VALUE")]),e._v(" is an "),s("code",{pre:!0},[e._v("unsigned long")]),e._v(". As "),s("code",{pre:!0},[e._v("VALUE")]),e._v(" is a pointer, it may look like "),s("code",{pre:!0},[e._v("void*")]),e._v(" would also be all right, but there is a reason for not doing this. In fact, "),s("code",{pre:!0},[e._v("VALUE")]),e._v(" can also not be a pointer. The 6 cases for which "),s("code",{pre:!0},[e._v("VALUE")]),e._v(" is not a pointer are the following:")]),s("ul",[s("li",[e._v("small integers")]),s("li",[e._v("symbols")]),s("li",[s("code",{pre:!0},[e._v("true")])]),s("li",[s("code",{pre:!0},[e._v("false")])]),s("li",[s("code",{pre:!0},[e._v("nil")])]),s("li",[s("code",{pre:!0},[e._v("Qundef")])])]),s("p",[e._v("I'll explain them one by one.")]),s("h4",{attrs:{id:"small-integers"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#small-integers"}},[e._v("¶")]),e._v(" Small integers")]),s("p",[e._v("As in Ruby all data are objects, integers are also objects. However, as there are lots of different instances of integers, expressing them as structures would risk slowing down execution. For example, when incrementing from 0 to 50000, just for this creating 50000 objects would make us hesitate.")]),s("p",[e._v("That's why in "),s("code",{pre:!0},[e._v("ruby")]),e._v(", to some extent, small integers are treated specially and embedded directly into "),s("code",{pre:!0},[e._v("VALUE")]),e._v('. "small" means signed integers that can be held in '),s("code",{pre:!0},[e._v("sizeof(VALUE)*8-1")]),e._v(" bits. In other words, on 32 bits machines, the integers have 1 bit for the sign, and 30 bits for the integer part. Integers in this range will belong to the "),s("code",{pre:!0},[e._v("Fixnum")]),e._v(" class and the other integers will belong to the "),s("code",{pre:!0},[e._v("Bignum")]),e._v(" class.")]),s("p",[e._v("Then, let's see in practice the "),s("code",{pre:!0},[e._v("INT2FIX()")]),e._v(" macro that converts from a C "),s("code",{pre:!0},[e._v("int")]),e._v(" to a "),s("code",{pre:!0},[e._v("Fixnum")]),e._v(", and confirm that "),s("code",{pre:!0},[e._v("Fixnum")]),e._v(" are directly embedded in "),s("code",{pre:!0},[e._v("VALUE")]),e._v(".")]),s("p",[e._v("▼ "),s("code",{pre:!0},[e._v("INT2FIX")])]),s("pre",{pre:!0},[s("code",{pre:!0,attrs:{"v-pre":""}},[e._v(" 123  #define INT2FIX(i) ((VALUE)(((long)(i))<<1 | FIXNUM_FLAG))\n 122  #define FIXNUM_FLAG 0x01\n\n(ruby.h)\n")])]),s("p",[e._v("In brief, shift 1 bit to the right, and bitwise or it with 1.")]),s("p",[e._v("| "),s("code",{pre:!0},[e._v("0110100001000")]),e._v(" | before conversion | | "),s("code",{pre:!0},[e._v("1101000010001")]),e._v(" | after conversion |")]),s("p",[e._v("That means that "),s("code",{pre:!0},[e._v("Fixnum")]),e._v(" as "),s("code",{pre:!0},[e._v("VALUE")]),e._v(" will always be an odd number. On the other hand, as Ruby object structures are allocated with "),s("code",{pre:!0},[e._v("malloc()")]),e._v(", they are generally arranged on addresses multiple of 4. So they do not overlap with the values of "),s("code",{pre:!0},[e._v("Fixnum")]),e._v(" as "),s("code",{pre:!0},[e._v("VALUE")]),e._v(".")]),s("p",[e._v("Also, to convert "),s("code",{pre:!0},[e._v("int")]),e._v(" or "),s("code",{pre:!0},[e._v("long")]),e._v(" to "),s("code",{pre:!0},[e._v("VALUE")]),e._v(", we can use macros like "),s("code",{pre:!0},[e._v("INT2NUM()")]),e._v(" or "),s("code",{pre:!0},[e._v("LONG2NUM()")]),e._v(". Any conversion macro "),s("code",{pre:!0},[e._v("XXXX2XXXX")]),e._v(" with a name containing "),s("code",{pre:!0},[e._v("NUM")]),e._v(" can manage both "),s("code",{pre:!0},[e._v("Fixnum")]),e._v(" and "),s("code",{pre:!0},[e._v("Bignum")]),e._v(". For example if "),s("code",{pre:!0},[e._v("INT2NUM()")]),e._v(" can't convert an integer into a "),s("code",{pre:!0},[e._v("Fixnum")]),e._v(", it will automatically convert it to "),s("code",{pre:!0},[e._v("Bignum")]),e._v(". "),s("code",{pre:!0},[e._v("NUM2INT()")]),e._v(" will convert both "),s("code",{pre:!0},[e._v("Fixnum")]),e._v(" and "),s("code",{pre:!0},[e._v("Bignum")]),e._v(" to "),s("code",{pre:!0},[e._v("int")]),e._v(". If the number can't fit in an "),s("code",{pre:!0},[e._v("int")]),e._v(", an exception will be raised, so there is not need to check the value range.")]),s("h4",{attrs:{id:"symbols"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#symbols"}},[e._v("¶")]),e._v(" Symbols")]),s("p",[e._v("What are symbols?")]),s("p",[e._v("As this question is quite troublesome to answer, let's start with the reasons why symbols were necessary. First, let's start with the "),s("code",{pre:!0},[e._v("ID")]),e._v(" type used inside "),s("code",{pre:!0},[e._v("ruby")]),e._v(". It's like this:")]),s("p",[e._v("▼ "),s("code",{pre:!0},[e._v("ID")])]),s("pre",{pre:!0},[s("code",{pre:!0,attrs:{"v-pre":""}},[e._v("  72  typedef unsigned long ID;\n\n(ruby.h)\n")])]),s("p",[e._v("This "),s("code",{pre:!0},[e._v("ID")]),e._v(" is a number having a one-to-one association with a string. However, in this world it's not possible to have an association between all strings and a numerical value. That's why they are limited to the one to one relationships inside one "),s("code",{pre:!0},[e._v("ruby")]),e._v(" process. I'll speak of the method to find an "),s("code",{pre:!0},[e._v("ID")]),e._v(' in the next chapter "Names and name tables".')]),s("p",[e._v("In language implementations, there are a lot of names to handle. Method names or variable names, constant names, file names in class names... It's troublesome to handle all of them as strings ("),s("code",{pre:!0},[e._v("char*")]),e._v('), because of memory management and memory management and memory management... Also, lots of comparisons would certainly be necessary, but comparing strings character by character will slow down the execution. That\'s why strings are not handled directly, something will be associated and used instead. And generally "something" will be integers, as they are the simplest to handle.')]),s("p",[e._v("These "),s("code",{pre:!0},[e._v("ID")]),e._v(" are found as symbols in the Ruby world. Up to "),s("code",{pre:!0},[e._v("ruby 1.4")]),e._v(", the values of "),s("code",{pre:!0},[e._v("ID")]),e._v(" where converted to "),s("code",{pre:!0},[e._v("Fixnum")]),e._v(", but used as symbols. Even today these values can be obtained using "),s("code",{pre:!0},[e._v("Symbol#to_i")]),e._v(". However, as real use results came piling up, it was understood that making "),s("code",{pre:!0},[e._v("Fixnum")]),e._v(" and "),s("code",{pre:!0},[e._v("Symbol")]),e._v(" the same was not a good idea, so since 1.6 an independent class "),s("code",{pre:!0},[e._v("Symbol")]),e._v(" has been created.")]),s("p",[s("code",{pre:!0},[e._v("Symbol")]),e._v(" objects are used a lot, especially as keys for hash tables. That's why "),s("code",{pre:!0},[e._v("Symbol")]),e._v(", like "),s("code",{pre:!0},[e._v("Fixnum")]),e._v(", was made stored in "),s("code",{pre:!0},[e._v("VALUE")]),e._v(". Let's look at the "),s("code",{pre:!0},[e._v("ID2SYM()")]),e._v(" macro converting "),s("code",{pre:!0},[e._v("ID")]),e._v(" to "),s("code",{pre:!0},[e._v("Symbol")]),e._v(" object.")]),s("p",[e._v("▼ "),s("code",{pre:!0},[e._v("ID2SYM")])]),s("pre",{pre:!0},[s("code",{pre:!0,attrs:{"v-pre":""}},[e._v(" 158  #define SYMBOL_FLAG 0x0e\n 160  #define ID2SYM(x) ((VALUE)(((long)(x))<<8|SYMBOL_FLAG))\n\n(ruby.h)\n")])]),s("p",[e._v("When shifting 8 bits left, "),s("code",{pre:!0},[e._v("x")]),e._v(" becomes a multiple of 256, that means a multiple of 4. Then after with a bitwise or (in this case it's the same as adding) with "),s("code",{pre:!0},[e._v("0x0e")]),e._v(" (14 in decimal), the "),s("code",{pre:!0},[e._v("VALUE")]),e._v(" expressing the symbol is not a multiple of 4. Or even an odd number. So it does not overlap the range of any other "),s("code",{pre:!0},[e._v("VALUE")]),e._v(". Quite a clever trick.")]),s("p",[e._v("Finally, let's see the reverse conversion of "),s("code",{pre:!0},[e._v("ID2SYM()")]),e._v(", "),s("code",{pre:!0},[e._v("SYM2ID()")]),e._v(".")]),s("p",[e._v("▼ "),s("code",{pre:!0},[e._v("SYM2ID()")])]),s("pre",{pre:!0},[s("code",{pre:!0,attrs:{"v-pre":""}},[e._v(" 161  #define SYM2ID(x) RSHIFT((long)x,8)\n\n(ruby.h)\n")])]),s("p",[s("code",{pre:!0},[e._v("RSHIFT")]),e._v(" is a bit shift to the right. As right shift may keep or not the sign depending of the platform, it became a macro.")]),s("h4",{attrs:{id:"true-false-nil"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#true-false-nil"}},[e._v("¶")]),e._v(" "),s("code",{pre:!0},[e._v("true false nil")])]),s("p",[e._v("These three are Ruby special objects. "),s("code",{pre:!0},[e._v("true")]),e._v(" and "),s("code",{pre:!0},[e._v("false")]),e._v(" represent the boolean values. "),s("code",{pre:!0},[e._v("nil")]),e._v(" is an object used to denote that there is no object. Their values at the C level are defined like this:")]),s("p",[e._v("▼ "),s("code",{pre:!0},[e._v("true false nil")])]),s("pre",{pre:!0},[s("code",{pre:!0,attrs:{"v-pre":""}},[e._v(" 164  #define Qfalse 0        /* Ruby's false */\n 165  #define Qtrue  2        /* Ruby's true */\n 166  #define Qnil   4        /* Ruby's nil */\n\n(ruby.h)\n")])]),s("p",[e._v("This time it's even numbers, but as 0 or 2 can't be used by pointers, they can't overlap with other "),s("code",{pre:!0},[e._v("VALUE")]),e._v(". It's because usually the first bloc of virtual memory is not allocated, to make the programs dereferencing a "),s("code",{pre:!0},[e._v("NULL")]),e._v(" pointer crash.")]),s("p",[e._v("And as "),s("code",{pre:!0},[e._v("Qfalse")]),e._v(" is 0, it can also be used as false at C level. In practice, in "),s("code",{pre:!0},[e._v("ruby")]),e._v(", when a function returns a boolean value, it's often made to return an "),s("code",{pre:!0},[e._v("int")]),e._v(" or "),s("code",{pre:!0},[e._v("VALUE")]),e._v(", and returns "),s("code",{pre:!0},[e._v("Qtrue")]),e._v("/"),s("code",{pre:!0},[e._v("Qfalse")]),e._v(".")]),s("p",[e._v("For "),s("code",{pre:!0},[e._v("Qnil")]),e._v(", there is a macro dedicated to check if a "),s("code",{pre:!0},[e._v("VALUE")]),e._v(" is "),s("code",{pre:!0},[e._v("Qnil")]),e._v(" or not, "),s("code",{pre:!0},[e._v("NIL_P()")]),e._v(".")]),s("p",[e._v("▼ "),s("code",{pre:!0},[e._v("NIL_P()")])]),s("pre",{pre:!0},[s("code",{pre:!0,attrs:{"v-pre":""}},[e._v(" 170  #define NIL_P(v) ((VALUE)(v) == Qnil)\n\n(ruby.h)\n")])]),s("p",[e._v("The name ending with "),s("code",{pre:!0},[e._v("p")]),e._v(" is a notation coming from Lisp denoting that it is a function returning a boolean value. In other words, "),s("code",{pre:!0},[e._v("NIL_P")]),e._v(' means "is the argument '),s("code",{pre:!0},[e._v("nil")]),e._v('?". It seems the "'),s("code",{pre:!0},[e._v("p")]),e._v('" character comes from "predicate". This naming rule is used at many different places in '),s("code",{pre:!0},[e._v("ruby")]),e._v(".")]),s("p",[e._v("Also, in Ruby, "),s("code",{pre:!0},[e._v("false")]),e._v(" and "),s("code",{pre:!0},[e._v("nil")]),e._v(" are false and all the other objects are true. However, in C, "),s("code",{pre:!0},[e._v("nil")]),e._v(" ("),s("code",{pre:!0},[e._v("Qnil")]),e._v(") is true. That's why in C a Ruby-style macro, "),s("code",{pre:!0},[e._v("RTEST()")]),e._v(", has been created.")]),s("p",[e._v("▼ "),s("code",{pre:!0},[e._v("RTEST()")])]),s("pre",{pre:!0},[s("code",{pre:!0,attrs:{"v-pre":""}},[e._v(" 169  #define RTEST(v) (((VALUE)(v) & ~Qnil) != 0)\n\n(ruby.h)\n")])]),s("p",[e._v("As in "),s("code",{pre:!0},[e._v("Qnil")]),e._v(" only the third lower bit is 1, in "),s("code",{pre:!0},[e._v("~Qnil")]),e._v(" only the third lower bit is 0. Then only "),s("code",{pre:!0},[e._v("Qfalse")]),e._v(" and "),s("code",{pre:!0},[e._v("Qnil")]),e._v(" become 0 with a bitwise and.")]),s("p",[s("code",{pre:!0},[e._v("!=0")]),e._v(' has be added to be certain to only have 0 or 1, to satisfy the requirements of the glib library that only wants 0 or 1 ("[ruby-dev:11049]":http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-dev/11049).')]),s("p",[e._v("By the way, what is the '"),s("code",{pre:!0},[e._v("Q")]),e._v("' of "),s("code",{pre:!0},[e._v("Qnil")]),e._v("? 'R' I would have understood but why '"),s("code",{pre:!0},[e._v("Q")]),e._v("'? When I asked, the answer was \"Because it's like that in Emacs\". I did not have the fun answer I was expecting...")]),s("h4",{attrs:{id:"qundef"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#qundef"}},[e._v("¶")]),e._v(" "),s("code",{pre:!0},[e._v("Qundef")])]),s("p",[e._v("▼ "),s("code",{pre:!0},[e._v("Qundef")])]),s("pre",{pre:!0},[s("code",{pre:!0,attrs:{"v-pre":""}},[e._v(" 167  #define Qundef 6                /* undefined value for placeholder */\n\n(ruby.h)\n")])]),s("p",[e._v("This value is used to express an undefined value in the interpreter. It can't be found at all at the Ruby level.")]),s("h2",{attrs:{id:"methods"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#methods"}},[e._v("¶")]),e._v(" Methods")]),s("p",[e._v("I already brought up the three important points of a Ruby object, that is having an identity, being able to call a method, and keeping data for each instance. In this section, I'll explain in a simple way the structure linking objects and methods.")]),s("h3",{attrs:{id:"struct-rclass"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#struct-rclass"}},[e._v("¶")]),e._v(" "),s("code",{pre:!0},[e._v("struct RClass")])]),s("p",[e._v("In Ruby, classes exist as objects during the execution. Of course. So there must be a structure for class objects. That structure is "),s("code",{pre:!0},[e._v("struct RClass")]),e._v(". Its structure type flag is "),s("code",{pre:!0},[e._v("T_CLASS")]),e._v(".")]),s("p",[e._v("As class and modules are very similar, there is no need to differentiate their content. That's why modules also use the "),s("code",{pre:!0},[e._v("struct RClass")]),e._v(" structure, and are differentiated by the "),s("code",{pre:!0},[e._v("T_MODULE")]),e._v(" structure flag.")]),s("p",[e._v("▼ "),s("code",{pre:!0},[e._v("struct RClass")])]),s("pre",{pre:!0},[s("code",{pre:!0,attrs:{"v-pre":""}},[e._v(" 300  struct RClass {\n 301      struct RBasic basic;\n 302      struct st_table *iv_tbl;\n 303      struct st_table *m_tbl;\n 304      VALUE super;\n 305  };\n\n(ruby.h)\n")])]),s("p",[e._v("First, let's focus on the "),s("code",{pre:!0},[e._v("m_tbl")]),e._v(" (Method TaBLe) member. "),s("code",{pre:!0},[e._v("struct st_table")]),e._v(" is an hashtable used everywhere in "),s("code",{pre:!0},[e._v("ruby")]),e._v('. Its details will be explained in the next chapter "Names and name tables", but basically, it is a table mapping names to objects. In the case of '),s("code",{pre:!0},[e._v("m_tbl")]),e._v(", it keeps the correspondence between the name ("),s("code",{pre:!0},[e._v("ID")]),e._v(") of the methods possessed by this class and the methods entity itself.")]),s("p",[e._v("The fourth member "),s("code",{pre:!0},[e._v("super")]),e._v(" keeps, like its name suggests, the superclass. As it's a "),s("code",{pre:!0},[e._v("VALUE")]),e._v(", it's (a pointer to) the class object of the superclass. In Ruby there is only one class that has no superclass (the root class): "),s("code",{pre:!0},[e._v("Object")]),e._v(".")]),s("p",[e._v("However I already said that all "),s("code",{pre:!0},[e._v("Object")]),e._v(" methods are defined in the "),s("code",{pre:!0},[e._v("Kernel")]),e._v(" module, "),s("code",{pre:!0},[e._v("Object")]),e._v(" just includes it. As modules are functionally similar to multiple inheritance, it may seem having just "),s("code",{pre:!0},[e._v("super")]),e._v(" is problematic, but but in "),s("code",{pre:!0},[e._v("ruby")]),e._v(' some clever changes are made to make it look like single inheritance. The details of this process will be explained in the fourth chapter "Classes and modules".')]),s("p",[e._v("Because of this, "),s("code",{pre:!0},[e._v("super")]),e._v(" of the structure of "),s("code",{pre:!0},[e._v("Object")]),e._v(" points to "),s("code",{pre:!0},[e._v("struct RClass")]),e._v(" of the "),s("code",{pre:!0},[e._v("Kernel")]),e._v(" object. Only the "),s("code",{pre:!0},[e._v("super")]),e._v(" of Kernel is NULL. So contrary to what I said, if "),s("code",{pre:!0},[e._v("super")]),e._v(" is NULL, this "),s("code",{pre:!0},[e._v("RClass")]),e._v(" is the "),s("code",{pre:!0},[e._v("Kernel")]),e._v(" object (figure 6).")]),s("p",[s("img",{attrs:{src:r("aa7c"),alt:"(Class tree at the C level)"}})]),s("h3",{attrs:{id:"methods-search"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#methods-search"}},[e._v("¶")]),e._v(" Methods search")]),s("p",[e._v("With classes structured like this, you can easily imagine the method call process. The "),s("code",{pre:!0},[e._v("m_tbl")]),e._v(" of the object's class is searched, and if the method was not found, the "),s("code",{pre:!0},[e._v("m_tbl")]),e._v(" of "),s("code",{pre:!0},[e._v("super")]),e._v(" is searched, and so on. If there is no more "),s("code",{pre:!0},[e._v("super")]),e._v(", that is to say the method was not found even in "),s("code",{pre:!0},[e._v("Object")]),e._v(", then it must not be defined.")]),s("p",[e._v("The sequential search process in "),s("code",{pre:!0},[e._v("m_tbl")]),e._v(" is done by "),s("code",{pre:!0},[e._v("search_method()")]),e._v(".")]),s("p",[e._v("▼ "),s("code",{pre:!0},[e._v("search_method()")])]),s("pre",{pre:!0},[s("code",{pre:!0,attrs:{"v-pre":""}},[e._v(" 256  static NODE*\n 257  search_method(klass, id, origin)\n 258      VALUE klass, *origin;\n 259      ID id;\n 260  {\n 261      NODE *body;\n 262\n 263      if (!klass) return 0;\n 264      while (!st_lookup(RCLASS(klass)->m_tbl, id, &body)) {\n 265          klass = RCLASS(klass)->super;\n 266          if (!klass) return 0;\n 267      }\n 268\n 269      if (origin) *origin = klass;\n 270      return body;\n 271  }\n\n(eval.c)\n")])]),s("p",[e._v("This function searches the method named "),s("code",{pre:!0},[e._v("id")]),e._v(" in the class object "),s("code",{pre:!0},[e._v("klass")]),e._v(".")]),s("p",[s("code",{pre:!0},[e._v("RCLASS(value)")]),e._v(" is the macro doing:")]),s("pre",{pre:!0},[s("code",{pre:!0,attrs:{"v-pre":""}},[e._v("((struct RClass*)(value))\n")])]),s("p",[s("code",{pre:!0},[e._v("st_lookup()")]),e._v(" is a function that searches in "),s("code",{pre:!0},[e._v("st_table")]),e._v(" the value corresponding to a key. If the value is found, the function returns true and puts the found value at the address given in third parameter ("),s("code",{pre:!0},[e._v("&body")]),e._v(").")]),s("p",[e._v("Nevertheless, doing this search each time whatever the circumstances would be too slow. That's why in reality, once called, a method is cached. So starting from the second time it will be found without following "),s("code",{pre:!0},[e._v("super")]),e._v(' one by one. This cache and its search will be seen in the 15th chapter "Methods".')]),s("h2",{attrs:{id:"instance-variables"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#instance-variables"}},[e._v("¶")]),e._v(" Instance variables")]),s("p",[e._v("In this section, I will explain the implementation of the third essential condition, instance variables.")]),s("h3",{attrs:{id:"rb_ivar_set()"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#rb_ivar_set()"}},[e._v("¶")]),e._v(" "),s("code",{pre:!0},[e._v("rb_ivar_set()")])]),s("p",[e._v("Instance variables are what allows each object to store characteristic data. Having it stored in the object itself (i.e. in the object structure) may seem all right but how is it in practice? Let's look at the function "),s("code",{pre:!0},[e._v("rb_ivar_set()")]),e._v(" that puts an object in an instance variable.")]),s("p",[e._v("▼ "),s("code",{pre:!0},[e._v("rb_ivar_set()")])]),s("pre",{pre:!0},[s("code",{pre:!0,attrs:{"v-pre":""}},[e._v('      /* write val in the id instance of obj */\n 984  VALUE\n 985  rb_ivar_set(obj, id, val)\n 986      VALUE obj;\n 987      ID id;\n 988      VALUE val;\n 989  {\n 990      if (!OBJ_TAINTED(obj) && rb_safe_level() >= 4)\n 991          rb_raise(rb_eSecurityError,\n                       "Insecure: can\'t modify instance variable");\n 992      if (OBJ_FROZEN(obj)) rb_error_frozen("object");\n 993      switch (TYPE(obj)) {\n 994        case T_OBJECT:\n 995        case T_CLASS:\n 996        case T_MODULE:\n 997          if (!ROBJECT(obj)->iv_tbl)\n                  ROBJECT(obj)->iv_tbl = st_init_numtable();\n 998          st_insert(ROBJECT(obj)->iv_tbl, id, val);\n 999          break;\n1000        default:\n1001          generic_ivar_set(obj, id, val);\n1002          break;\n1003      }\n1004      return val;\n1005  }\n\n(variable.c)\n')])]),s("p",[s("code",{pre:!0},[e._v("rb_raise()")]),e._v(" and "),s("code",{pre:!0},[e._v("rb_error_frozen()")]),e._v(" are both error checks. Error checks are necessary, but it's not the main part of the treatment, so you should ignore them at first read.")]),s("p",[e._v("After removing error treatment, only the "),s("code",{pre:!0},[e._v("switch")]),e._v(" remains, but this")]),s("pre",{pre:!0},[s("code",{pre:!0,attrs:{"v-pre":""}},[e._v("switch (TYPE(obj)) {\n  case T_aaaa:\n  case T_bbbb:\n     ...\n}\n")])]),s("p",[e._v("form is characteristic of "),s("code",{pre:!0},[e._v("ruby")]),e._v(". "),s("code",{pre:!0},[e._v("TYPE()")]),e._v(" is the macro returning the type flag of the object structure ("),s("code",{pre:!0},[e._v("T_OBJECT")]),e._v(", "),s("code",{pre:!0},[e._v("T_STRING")]),e._v(", etc.). In other words as the type flag is an integer constant, we can branch depending on it with a "),s("code",{pre:!0},[e._v("switch")]),e._v(". "),s("code",{pre:!0},[e._v("Fixnum")]),e._v(" or "),s("code",{pre:!0},[e._v("Symbol")]),e._v(" do not have structures, but inside "),s("code",{pre:!0},[e._v("TYPE()")]),e._v(" a special treatment is done to properly return "),s("code",{pre:!0},[e._v("T_FIXNUM")]),e._v(" and "),s("code",{pre:!0},[e._v("T_SYMBOL")]),e._v(", so there's no need to worry.")]),s("p",[e._v("Well, let's go back to "),s("code",{pre:!0},[e._v("rb_ivar_set()")]),e._v(". It seems only the treatments of "),s("code",{pre:!0},[e._v("T_OBJECT")]),e._v(", "),s("code",{pre:!0},[e._v("T_CLASS")]),e._v(" and "),s("code",{pre:!0},[e._v("T_MODULE")]),e._v(" are different. These 3 have been chosen on the basis that their second member is "),s("code",{pre:!0},[e._v("iv_tbl")]),e._v(". Let's confirm it in practice.")]),s("p",[e._v("▼ Structures whose second member is "),s("code",{pre:!0},[e._v("iv_tbl")])]),s("pre",{pre:!0},[s("code",{pre:!0,attrs:{"v-pre":""}},[e._v("      /* TYPE(val) == T_OBJECT */\n 295  struct RObject {\n 296      struct RBasic basic;\n 297      struct st_table *iv_tbl;\n 298  };\n\n      /* TYPE(val) == T_CLASS or T_MODULE */\n 300  struct RClass {\n 301      struct RBasic basic;\n 302      struct st_table *iv_tbl;\n 303      struct st_table *m_tbl;\n 304      VALUE super;\n 305  };\n\n(ruby.h)\n")])]),s("p",[s("code",{pre:!0},[e._v("iv_tbl")]),e._v(" is the Instance Variable TaBLe. It stores instance variable names and their corresponding value.")]),s("p",[e._v("In "),s("code",{pre:!0},[e._v("rb_ivar_set()")]),e._v(", let's look again the code for the structures having "),s("code",{pre:!0},[e._v("iv_tbl")]),e._v(".")]),s("pre",{pre:!0},[s("code",{pre:!0,attrs:{"v-pre":""}},[e._v("if (!ROBJECT(obj)->iv_tbl)\n    ROBJECT(obj)->iv_tbl = st_init_numtable();\nst_insert(ROBJECT(obj)->iv_tbl, id, val);\nbreak;\n")])]),s("p",[s("code",{pre:!0},[e._v("ROBJECT()")]),e._v(" is a macro that casts a "),s("code",{pre:!0},[e._v("VALUE")]),e._v(" into a "),s("code",{pre:!0},[e._v("struct RObject*")]),e._v(". It's possible that "),s("code",{pre:!0},[e._v("obj")]),e._v(" points to a struct RClass, but as we're only going to access the second member no problem will occur.")]),s("p",[s("code",{pre:!0},[e._v("st_init_numtable()")]),e._v(" is a function creating a new "),s("code",{pre:!0},[e._v("st_table")]),e._v(". "),s("code",{pre:!0},[e._v("st_insert()")]),e._v(" is a function doing associations in a "),s("code",{pre:!0},[e._v("st_table")]),e._v(".")]),s("p",[e._v("In conclusion, this code does the following: if "),s("code",{pre:!0},[e._v("iv_tbl")]),e._v(" does not exist, it creates it, then stores the [variable name → object] association.")]),s("p",[e._v("Warning: as "),s("code",{pre:!0},[e._v("struct RClass")]),e._v(" is a class object, this instance variable table is for the use of the class object itself. In Ruby programs, it corresponds to something like the following:")]),s("pre",{pre:!0},[s("code",{pre:!0,attrs:{"v-pre":""}},[e._v('class C\n  @ivar = "content"\nend\n')])]),s("h3",{attrs:{id:"generic_ivar_set()"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#generic_ivar_set()"}},[e._v("¶")]),e._v(" "),s("code",{pre:!0},[e._v("generic_ivar_set()")])]),s("p",[e._v("For objects for which the structure used is not "),s("code",{pre:!0},[e._v("T_OBJECT")]),e._v(", "),s("code",{pre:!0},[e._v("T_MODULE")]),e._v(", or "),s("code",{pre:!0},[e._v("T_CLASS")]),e._v(", what happens when modifying an instance variable?")]),s("p",[e._v("▼ "),s("code",{pre:!0},[e._v("rb_ivar_set()")]),e._v(" in the case there is no "),s("code",{pre:!0},[e._v("iv_tbl")])]),s("pre",{pre:!0},[s("code",{pre:!0,attrs:{"v-pre":""}},[e._v("1000  default:\n1001    generic_ivar_set(obj, id, val);\n1002    break;\n\n(variable.c)\n")])]),s("p",[e._v("The control is transferred to "),s("code",{pre:!0},[e._v("generic_ivar_set()")]),e._v(". Before looking at this function, let's first explain its general idea.")]),s("p",[e._v("Structures that are not "),s("code",{pre:!0},[e._v("T_OBJECT")]),e._v(", "),s("code",{pre:!0},[e._v("T_MODULE")]),e._v(" or "),s("code",{pre:!0},[e._v("T_CLASS")]),e._v(" do not have an "),s("code",{pre:!0},[e._v("iv_tbl")]),e._v(" member (the reason why they do not have it will be explained later). However, a method linking an instance to a "),s("code",{pre:!0},[e._v("struct st_table")]),e._v(" would allow instances to have instance variables. In "),s("code",{pre:!0},[e._v("ruby")]),e._v(", this was solved by using a global "),s("code",{pre:!0},[e._v("st_table")]),e._v(", "),s("code",{pre:!0},[e._v("generic_iv_table")]),e._v(" (figure 7) for these associations.")]),s("p",[s("img",{attrs:{src:r("b054"),alt:"()"}})]),s("p",[e._v("Let's see this in practice.")]),s("p",[e._v("▼ "),s("code",{pre:!0},[e._v("generic_ivar_set()")])]),s("pre",{pre:!0},[s("code",{pre:!0,attrs:{"v-pre":""}},[e._v(" 801  static st_table *generic_iv_tbl;\n\n 830  static void\n 831  generic_ivar_set(obj, id, val)\n 832      VALUE obj;\n 833      ID id;\n 834      VALUE val;\n 835  {\n 836      st_table *tbl;\n 837\n          /* for the time being you should ignore this */\n 838      if (rb_special_const_p(obj)) {\n 839          special_generic_ivar = 1;\n 840      }\n          /* initialize generic_iv_tbl if it does not exist */\n 841      if (!generic_iv_tbl) {\n 842          generic_iv_tbl = st_init_numtable();\n 843      }\n 844\n          /* the treatment itself */\n 845      if (!st_lookup(generic_iv_tbl, obj, &tbl)) {\n 846          FL_SET(obj, FL_EXIVAR);\n 847          tbl = st_init_numtable();\n 848          st_add_direct(generic_iv_tbl, obj, tbl);\n 849          st_add_direct(tbl, id, val);\n 850          return;\n 851      }\n 852      st_insert(tbl, id, val);\n 853  }\n\n(variable.c)\n")])]),s("p",[s("code",{pre:!0},[e._v("rb_special_const_p()")]),e._v(" is true when its parameter is not a pointer. However, as this "),s("code",{pre:!0},[e._v("if")]),e._v(" part requires knowledge of the garbage collector, we'll skip it for now. I'd like you to check it again after reading the chapter 5 \"Garbage collection\".")]),s("p",[s("code",{pre:!0},[e._v("st_init_numtable()")]),e._v(" already appeared some time ago. It creates a new hash table.")]),s("p",[s("code",{pre:!0},[e._v("st_lookup()")]),e._v(" searches a value corresponding to a key. In this case it searches for what's attached to "),s("code",{pre:!0},[e._v("obj")]),e._v(". If an attached value can be found, the whole function returns true and stores the value at the address ("),s("code",{pre:!0},[e._v("&tbl")]),e._v(") given as third parameter. In short, "),s("code",{pre:!0},[e._v("!st_lookup(...)")]),e._v(' can be read "if a value can\'t be found".')]),s("p",[s("code",{pre:!0},[e._v("st_insert()")]),e._v(" was also already explained. It stores a new association in a table.")]),s("p",[s("code",{pre:!0},[e._v("st_add_direct()")]),e._v(" is similar to "),s("code",{pre:!0},[e._v("st_insert()")]),e._v(", but the part before adding the association that checks if the key was already stored or not is different. In other words, in the case of "),s("code",{pre:!0},[e._v("st_add_direct()")]),e._v(", if a key already registered is being used, two associations linked to this same key will be stored. "),s("code",{pre:!0},[e._v("st_add_direct()")]),e._v(" can be used when the check for existence has already been done, as is the case here, or when a new table has just been created.")]),s("p",[s("code",{pre:!0},[e._v("FL_SET(obj, FL_EXIVAR)")]),e._v(" is the macro that sets the "),s("code",{pre:!0},[e._v("FL_EXIVAR")]),e._v(" flag in the "),s("code",{pre:!0},[e._v("basic.flags")]),e._v(" of "),s("code",{pre:!0},[e._v("obj")]),e._v(". The "),s("code",{pre:!0},[e._v("basic.flags")]),e._v(" flags are all named "),s("code",{pre:!0},[e._v("FL_xxxx")]),e._v(" and can be set using "),s("code",{pre:!0},[e._v("FL_SET()")]),e._v(". These flags can be unset with "),s("code",{pre:!0},[e._v("FL_UNSET()")]),e._v(". The "),s("code",{pre:!0},[e._v("EXIVAR")]),e._v(" from "),s("code",{pre:!0},[e._v("FL_EXIVAR")]),e._v(" seems to be the abbreviation of EXternal Instance VARiable.")]),s("p",[e._v("The setting of these flags is done to speed up the reading of instance variables. If "),s("code",{pre:!0},[e._v("FL_EXIVAR")]),e._v(" is not set, even without searching in "),s("code",{pre:!0},[e._v("generic_iv_tbl")]),e._v(", we directly know if the object has instance variables. And of course a bit check is way faster than searching a "),s("code",{pre:!0},[e._v("struct st_table")]),e._v(".")]),s("h3",{attrs:{id:"gaps-in-structures"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#gaps-in-structures"}},[e._v("¶")]),e._v(" Gaps in structures")]),s("p",[e._v("Now you should understand how the instance variables are stored, but why are there structures without "),s("code",{pre:!0},[e._v("iv_tbl")]),e._v("? Why is there no "),s("code",{pre:!0},[e._v("iv_tbl")]),e._v(" in "),s("code",{pre:!0},[e._v("struct RString")]),e._v(" or "),s("code",{pre:!0},[e._v("struct RArray")]),e._v("? Couldn't "),s("code",{pre:!0},[e._v("iv_tbl")]),e._v(" be part of "),s("code",{pre:!0},[e._v("RBasic")]),e._v("?")]),s("p",[e._v("Well, this could have been done, but there are good reasons why it was not. As a matter of fact, this problem is deeply linked to the way "),s("code",{pre:!0},[e._v("ruby")]),e._v(" manages objects.")]),s("p",[e._v("In "),s("code",{pre:!0},[e._v("ruby")]),e._v(", memory used by for example string data ("),s("code",{pre:!0},[e._v("char[]")]),e._v(") is directly allocated using "),s("code",{pre:!0},[e._v("malloc()")]),e._v(". However, the object structures are handled in a particular way. "),s("code",{pre:!0},[e._v("ruby")]),e._v(" allocates them by clusters, and then distribute them from these clusters. As at allocation time the diversity of types (and sizes) of structures is difficult to handle, a type ("),s("code",{pre:!0},[e._v("union")]),e._v(") that combines all structures "),s("code",{pre:!0},[e._v("RVALUE")]),e._v(" was declared and an array of this type is managed. As this type's size is the same as the biggest one of its members, if there is only one big structure, there is a lot of unused space. That's why doing as much as possible to regroup structures of similar size is desirable. The details about "),s("code",{pre:!0},[e._v("RVALUE")]),e._v(' will be explained in chapter 5 "Garbage collection".')]),s("p",[e._v("Generally the most used structure is "),s("code",{pre:!0},[e._v("struct RString")]),e._v(". After that, in programs there are "),s("code",{pre:!0},[e._v("struct RArray")]),e._v(" (array), "),s("code",{pre:!0},[e._v("RHash")]),e._v(" (hash), "),s("code",{pre:!0},[e._v("RObject")]),e._v(" (user defined object), etc. However, this "),s("code",{pre:!0},[e._v("struct RObject")]),e._v(" only uses the space of "),s("code",{pre:!0},[e._v("struct RBasic")]),e._v(" + 1 pointer. On the other hand, "),s("code",{pre:!0},[e._v("struct RString")]),e._v(", "),s("code",{pre:!0},[e._v("RArray")]),e._v(" and "),s("code",{pre:!0},[e._v("RHash")]),e._v(" take the space of "),s("code",{pre:!0},[e._v("struct RBasic")]),e._v(" + 3 pointers. In other words, when putting a "),s("code",{pre:!0},[e._v("struct RObject")]),e._v(" in the shared entity, the space for 2 pointers is useless. And beyond that, if "),s("code",{pre:!0},[e._v("RString")]),e._v(" had 4 pointers, "),s("code",{pre:!0},[e._v("RObject")]),e._v(" would use less that half the size of the shared entity. As you would expect, it's wasteful.")]),s("p",[e._v("So the received merit for "),s("code",{pre:!0},[e._v("iv_tbl")]),e._v(" is more or less saving memory and speeding up. Furthermore we do not know if it is used often or not. In the facts, "),s("code",{pre:!0},[e._v("generic_iv_tbl")]),e._v(" was not introduced before "),s("code",{pre:!0},[e._v("ruby")]),e._v(" 1.2, so it was not possible to use instance variables in "),s("code",{pre:!0},[e._v("String")]),e._v(" or "),s("code",{pre:!0},[e._v("Array")]),e._v(" at this time. Nevertheless it was not so much of a problem. Making large amounts of memory useless just for such a functionality looks stupid.")]),s("p",[e._v("If you take all this into consideration, you can conclude that increasing the size of object structures does not do any good.")]),s("h3",{attrs:{id:"rb_ivar_get()"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#rb_ivar_get()"}},[e._v("¶")]),e._v(" "),s("code",{pre:!0},[e._v("rb_ivar_get()")])]),s("p",[e._v("We saw the "),s("code",{pre:!0},[e._v("rb_ivar_set()")]),e._v(" function that sets variables, so let's see quickly how to get them.")]),s("p",[e._v("▼ "),s("code",{pre:!0},[e._v("rb_ivar_get()")])]),s("pre",{pre:!0},[s("code",{pre:!0,attrs:{"v-pre":""}},[e._v(' 960  VALUE\n 961  rb_ivar_get(obj, id)\n 962      VALUE obj;\n 963      ID id;\n 964  {\n 965      VALUE val;\n 966\n 967      switch (TYPE(obj)) {\n      /* (A) */\n 968        case T_OBJECT:\n 969        case T_CLASS:\n 970        case T_MODULE:\n 971          if (ROBJECT(obj)->iv_tbl &&\n                  st_lookup(ROBJECT(obj)->iv_tbl, id, &val))\n 972              return val;\n 973          break;\n      /* (B) */\n 974        default:\n 975          if (FL_TEST(obj, FL_EXIVAR) || rb_special_const_p(obj))\n 976              return generic_ivar_get(obj, id);\n 977          break;\n 978      }\n      /* (C) */\n 979      rb_warning("instance variable %s not initialized", rb_id2name(id));\n 980\n 981      return Qnil;\n 982  }\n\n(variable.c)\n')])]),s("p",[e._v("The structure is strictly the same.")]),s("p",[e._v("(A) For "),s("code",{pre:!0},[e._v("struct RObject")]),e._v(" or "),s("code",{pre:!0},[e._v("RClass")]),e._v(", we search the variable in "),s("code",{pre:!0},[e._v("iv_tbl")]),e._v(". As "),s("code",{pre:!0},[e._v("iv_tbl")]),e._v(" can also be "),s("code",{pre:!0},[e._v("NULL")]),e._v(", we must check it before using it. Then if "),s("code",{pre:!0},[e._v("st_lookup()")]),e._v(" finds the relation, it returns true, so the whole "),s("code",{pre:!0},[e._v("if")]),e._v(' can be read as "If the instance variable has been set, return its value".')]),s("p",[e._v("(C) If no correspondence could be found, in other words if we read an instance variable that has not been set, we first leave the "),s("code",{pre:!0},[e._v("if")]),e._v(" then the "),s("code",{pre:!0},[e._v("switch")]),e._v(". "),s("code",{pre:!0},[e._v("rb_warning()")]),e._v(" will then issue a warning and "),s("code",{pre:!0},[e._v("nil")]),e._v(" will be returned. That's because you can read instance variables that have not been set in Ruby.")]),s("p",[e._v("(B) On the other hand, if the structure is neither "),s("code",{pre:!0},[e._v("struct RObject")]),e._v(" nor "),s("code",{pre:!0},[e._v("RClass")]),e._v(", the instance variable table is searched in "),s("code",{pre:!0},[e._v("generic_iv_tbl")]),e._v(". What "),s("code",{pre:!0},[e._v("generic_ivar_get()")]),e._v(" does can be easily guessed, so I won't explain it. I'd rather want you to focus on the "),s("code",{pre:!0},[e._v("if")]),e._v(".")]),s("p",[e._v("I already told you that "),s("code",{pre:!0},[e._v("generic_ivar_set()")]),e._v(" sets the "),s("code",{pre:!0},[e._v("FL_EXIVAR")]),e._v(" flag to make the check faster.")]),s("p",[e._v("And what is "),s("code",{pre:!0},[e._v("rb_special_const_p()")]),e._v("? This function returns true when its parameter "),s("code",{pre:!0},[e._v("obj")]),e._v(" does not point to a structure. As no structure means no "),s("code",{pre:!0},[e._v("basic.flags")]),e._v(", no flag can be set, and "),s("code",{pre:!0},[e._v("FL_xxxx()")]),e._v(" will always returns false. That's why these objects have to be treated specially.")]),s("h2",{attrs:{id:"structures-for-objects"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#structures-for-objects"}},[e._v("¶")]),e._v(" Structures for objects")]),s("p",[e._v("In this section we'll see simply, among object structures, what the important ones contain and how they are handled.")]),s("h3",{attrs:{id:"struct-rstring"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#struct-rstring"}},[e._v("¶")]),e._v(" "),s("code",{pre:!0},[e._v("struct RString")])]),s("p",[s("code",{pre:!0},[e._v("struct RString")]),e._v(" is the structure for the instances of the "),s("code",{pre:!0},[e._v("String")]),e._v(" class and its subclasses.")]),s("p",[e._v("▼ "),s("code",{pre:!0},[e._v("struct RString")])]),s("pre",{pre:!0},[s("code",{pre:!0,attrs:{"v-pre":""}},[e._v(" 314  struct RString {\n 315      struct RBasic basic;\n 316      long len;\n 317      char *ptr;\n 318      union {\n 319          long capa;\n 320          VALUE shared;\n 321      } aux;\n 322  };\n\n(ruby.h)\n")])]),s("p",[s("code",{pre:!0},[e._v("ptr")]),e._v(" is a pointer to the string, and "),s("code",{pre:!0},[e._v("len")]),e._v(" the length of that string. Very straightforward.")]),s("p",[e._v("Rather than a string, Ruby's string is more a byte array, and can contain any byte including "),s("code",{pre:!0},[e._v("NUL")]),e._v(". So when thinking at the Ruby level, ending the string with "),s("code",{pre:!0},[e._v("NUL")]),e._v(" does not mean anything. As C functions require "),s("code",{pre:!0},[e._v("NUL")]),e._v(", for convenience the ending "),s("code",{pre:!0},[e._v("NUL")]),e._v(" is there, however, it is not included in "),s("code",{pre:!0},[e._v("len")]),e._v(".")]),s("p",[e._v("When dealing with a string coming from the interpreter or an extension library, you can write "),s("code",{pre:!0},[e._v("RSTRING(str)->ptr")]),e._v(" or "),s("code",{pre:!0},[e._v("RSTRING(str)->len")]),e._v(", and access "),s("code",{pre:!0},[e._v("ptr")]),e._v(" and "),s("code",{pre:!0},[e._v("len")]),e._v(". But there are some points to pay attention to.")]),s("h1",{attrs:{id:"you-have-to-check-before-if-str-really-points-to-a-struct-rstring"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#you-have-to-check-before-if-str-really-points-to-a-struct-rstring"}},[e._v("¶")]),e._v(" you have to check before if "),s("code",{pre:!0},[e._v("str")]),e._v(" really points to a "),s("code",{pre:!0},[e._v("struct RString")])]),s("h1",{attrs:{id:"you-can-read-the-members%2C-but-you-must-not-modify-them"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#you-can-read-the-members%2C-but-you-must-not-modify-them"}},[e._v("¶")]),e._v(" you can read the members, but you must not modify them")]),s("h1",{attrs:{id:"you-can't-store-rstring(str)-%3Eptr-in-something-like-a-local-variable-and"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#you-can't-store-rstring(str)-%3Eptr-in-something-like-a-local-variable-and"}},[e._v("¶")]),e._v(" you can't store "),s("code",{pre:!0},[e._v("RSTRING(str)->ptr")]),e._v(" in something like a local variable and")]),s("p",[e._v("use it later")]),s("p",[e._v("Why is that? First, there is an important software engineering principle: Don't arbitrarily tamper with someone's data. Interface functions are there for a reason. However, there are concrete reasons in "),s("code",{pre:!0},[e._v("ruby")]),e._v("'s design why you should not do such things as consulting or storing a pointer, and that's related to the fourth member "),s("code",{pre:!0},[e._v("aux")]),e._v(". However, to explain properly how to use "),s("code",{pre:!0},[e._v("aux")]),e._v(", we have to explain first a little more of Ruby's strings' characteristics.")]),s("p",[e._v("Ruby's strings can be modified (are mutable). By mutable I mean after the following code:")]),s("pre",{pre:!0},[s("code",{pre:!0,attrs:{"v-pre":""}},[e._v('s = "str"        # create a string and assign it to s\ns.concat("ing")  # append "ing" to this string object\np(s)             # show the string\n')])]),s("p",[e._v("the content of the object pointed by "),s("code",{pre:!0},[e._v("s")]),e._v(' will become "'),s("code",{pre:!0},[e._v("string")]),e._v("\". It's different from Java or Python string objects. Java's "),s("code",{pre:!0},[e._v("StringBuffer")]),e._v(" is closer.")]),s("p",[e._v("And what's the relation? First, mutable means the length ("),s("code",{pre:!0},[e._v("len")]),e._v(") of the string can change. We have to increase or decrease the allocated memory size each time the length changes. We can of course use "),s("code",{pre:!0},[e._v("realloc()")]),e._v(" for that, but generally "),s("code",{pre:!0},[e._v("malloc()")]),e._v(" and "),s("code",{pre:!0},[e._v("realloc()")]),e._v(" are heavy operations. Having to "),s("code",{pre:!0},[e._v("realloc()")]),e._v(" each time the string changes is a huge burden.")]),s("p",[e._v("That's why the memory pointed by "),s("code",{pre:!0},[e._v("ptr")]),e._v(" has been allocated with a size a little bigger than "),s("code",{pre:!0},[e._v("len")]),e._v(". Because of that, if the added part can fit into the remaining memory, it's taken care of without calling "),s("code",{pre:!0},[e._v("realloc()")]),e._v(", so it's faster. The structure member "),s("code",{pre:!0},[e._v("aux.capa")]),e._v(" contains the length including this additional memory.")]),s("p",[e._v("So what is this other "),s("code",{pre:!0},[e._v("aux.shared")]),e._v("? It's to speed up the creation of literal strings. Have a look at the following Ruby program.")]),s("pre",{pre:!0},[s("code",{pre:!0,attrs:{"v-pre":""}},[e._v('while true do  # repeat indefinitely\n  a = "str"        # create a string with "str" as content and assign it to a\n  a.concat("ing")  # append "ing" to the object pointed by a\n  p(a)             # show "string"\nend\n')])]),s("p",[e._v("Whatever the number of times you repeat the loop, the fourth line's "),s("code",{pre:!0},[e._v("p")]),e._v(" has to show "),s("code",{pre:!0},[e._v('"string"')]),e._v(". That's why the code "),s("code",{pre:!0},[e._v('"str"')]),e._v(" should create, each time, a string object holding a different "),s("code",{pre:!0},[e._v("char[]")]),e._v(". However, if no change occurs for a lot of strings, useless copies of "),s("code",{pre:!0},[e._v("char[]")]),e._v(" can be created many times. It would be better to share one common "),s("code",{pre:!0},[e._v("char[]")]),e._v(".")]),s("p",[e._v("The trick that allows this to happen is "),s("code",{pre:!0},[e._v("aux.shared")]),e._v(". String objects created with a literal use one shared "),s("code",{pre:!0},[e._v("char[]")]),e._v('. When a change occurs, the string is copied in unshared memory, and the change is done on this new copy. This technique is called "copy-on-write". When using a shared '),s("code",{pre:!0},[e._v("char[]")]),e._v(", the flag "),s("code",{pre:!0},[e._v("ELTS_SHARED")]),e._v(" is set in the object structure's "),s("code",{pre:!0},[e._v("basic.flags")]),e._v(", and "),s("code",{pre:!0},[e._v("aux.shared")]),e._v(" contains the original object. "),s("code",{pre:!0},[e._v("ELTS")]),e._v(" seems to be the abbreviation of "),s("code",{pre:!0},[e._v("ELemenTS")]),e._v(".")]),s("p",[e._v("But, well, let's return to our talk about "),s("code",{pre:!0},[e._v("RSTRING(str)->ptr")]),e._v(". Even if consulting the pointer is OK, you must not modify it, first because the value of "),s("code",{pre:!0},[e._v("len")]),e._v(" or "),s("code",{pre:!0},[e._v("capa")]),e._v(" will no longer agree with the content, and also because when modifying strings created as litterals, "),s("code",{pre:!0},[e._v("aux.shared")]),e._v(" has to be separated.")]),s("p",[e._v("To finish this section about "),s("code",{pre:!0},[e._v("RString")]),e._v(", let's write some examples how to use it. "),s("code",{pre:!0},[e._v("str")]),e._v(" is a "),s("code",{pre:!0},[e._v("VALUE")]),e._v(" that points to "),s("code",{pre:!0},[e._v("RString")]),e._v(".")]),s("pre",{pre:!0},[s("code",{pre:!0,attrs:{"v-pre":""}},[e._v('RSTRING(str)->len;               /* length */\nRSTRING(str)->ptr[0];            /* first character */\nstr = rb_str_new("content", 7);  /* create a string with "content" as its content\n                                    the second parameter is the length */\nstr = rb_str_new2("content");    /* create a string with "content" as its content\n                                    its length is calculated with strlen() */\nrb_str_cat2(str, "end");         /* Concatenate a C string to a Ruby string */\n')])]),s("h3",{attrs:{id:"struct-rarray"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#struct-rarray"}},[e._v("¶")]),e._v(" "),s("code",{pre:!0},[e._v("struct RArray")])]),s("p",[s("code",{pre:!0},[e._v("struct RArray")]),e._v(" is the structure for the instances of Ruby's array class "),s("code",{pre:!0},[e._v("Array")]),e._v(".")]),s("p",[e._v("▼ "),s("code",{pre:!0},[e._v("struct RArray")])]),s("pre",{pre:!0},[s("code",{pre:!0,attrs:{"v-pre":""}},[e._v(" 324  struct RArray {\n 325      struct RBasic basic;\n 326      long len;\n 327      union {\n 328          long capa;\n 329          VALUE shared;\n 330      } aux;\n 331      VALUE *ptr;\n 332  };\n\n(ruby.h)\n")])]),s("p",[e._v("Except for the type of "),s("code",{pre:!0},[e._v("ptr")]),e._v(", this structure is almost the same as "),s("code",{pre:!0},[e._v("struct RString")]),e._v(". "),s("code",{pre:!0},[e._v("ptr")]),e._v(" points to the content of the array, and "),s("code",{pre:!0},[e._v("len")]),e._v(" is its length. "),s("code",{pre:!0},[e._v("aux")]),e._v(" is exactly the same as in "),s("code",{pre:!0},[e._v("struct RString")]),e._v(". "),s("code",{pre:!0},[e._v("aux.capa")]),e._v(' is the "real" length of the memory pointed by '),s("code",{pre:!0},[e._v("ptr")]),e._v(", and if "),s("code",{pre:!0},[e._v("ptr")]),e._v(" is shared, "),s("code",{pre:!0},[e._v("aux.shared")]),e._v(" stores the shared original array object.")]),s("p",[e._v("From this structure, it's clear that Ruby's "),s("code",{pre:!0},[e._v("Array")]),e._v(" is an array and not a list. So when the number of elements changes in a big way, a "),s("code",{pre:!0},[e._v("realloc()")]),e._v(" must be done, and if an element must be inserted at an other place than the end, a "),s("code",{pre:!0},[e._v("memmove()")]),e._v(" will occur. But even if we do it, it's moving so fast it's really impressive on current machines.")]),s("p",[e._v("That's why the way to access it is similar to "),s("code",{pre:!0},[e._v("RString")]),e._v(". You can consult "),s("code",{pre:!0},[e._v("RARRAY(arr)->ptr")]),e._v(" and "),s("code",{pre:!0},[e._v("RARRAY(arr)->len")]),e._v(" members, but can't set them, etc., etc. We'll only look at simple examples:")]),s("pre",{pre:!0},[s("code",{pre:!0,attrs:{"v-pre":""}},[e._v("/* manage an array from C */\nVALUE ary;\nary = rb_ary_new();             /* create an empty array */\nrb_ary_push(ary, INT2FIX(9));   /* push a Ruby 9 */\nRARRAY(ary)->ptr[0];            /* look what's at index 0 */\nrb_p(RARRAY(ary)->ptr[0]);      /* do p on ary[0] (the result is 9) */\n\n# manage an array from Ruby\nary = []      # create an empty array\nary.push(9)   # push 9\nary[0]        # look what's at index 0\np(ary[0])     # do p on ary[0] (the result is 9)\n")])]),s("h3",{attrs:{id:"struct-rregexp"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#struct-rregexp"}},[e._v("¶")]),e._v(" "),s("code",{pre:!0},[e._v("struct RRegexp")])]),s("p",[e._v("It's the structure for the instances of the regular expression class "),s("code",{pre:!0},[e._v("Regexp")]),e._v(".")]),s("p",[e._v("▼ "),s("code",{pre:!0},[e._v("struct RRegexp")])]),s("pre",{pre:!0},[s("code",{pre:!0,attrs:{"v-pre":""}},[e._v(" 334  struct RRegexp {\n 335      struct RBasic basic;\n 336      struct re_pattern_buffer *ptr;\n 337      long len;\n 338      char *str;\n 339  };\n\n(ruby.h)\n")])]),s("p",[s("code",{pre:!0},[e._v("ptr")]),e._v(" is the regular expression after compilation. "),s("code",{pre:!0},[e._v("str")]),e._v(" is the string before compilation (the source code of the regular expression), and "),s("code",{pre:!0},[e._v("len")]),e._v(" is this string's length.")]),s("p",[e._v("As the "),s("code",{pre:!0},[e._v("Regexp")]),e._v(" object handling code doesn't appear in this book, we won't see how to use it. Even if you use it in extension libraries, as long as you do not want to use it a very particular way, the interface functions are enough.")]),s("h3",{attrs:{id:"struct-rhash"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#struct-rhash"}},[e._v("¶")]),e._v(" "),s("code",{pre:!0},[e._v("struct RHash")])]),s("p",[s("code",{pre:!0},[e._v("struct RHash")]),e._v(" is the structure for Ruby's "),s("code",{pre:!0},[e._v("Hash")]),e._v(" objects.")]),s("p",[e._v("▼ "),s("code",{pre:!0},[e._v("struct RHash")])]),s("pre",{pre:!0},[s("code",{pre:!0,attrs:{"v-pre":""}},[e._v(" 341  struct RHash {\n 342      struct RBasic basic;\n 343      struct st_table *tbl;\n 344      int iter_lev;\n 345      VALUE ifnone;\n 346  };\n\n(ruby.h)\n")])]),s("p",[e._v("It's a wrapper for "),s("code",{pre:!0},[e._v("struct st_table")]),e._v(". "),s("code",{pre:!0},[e._v("st_table")]),e._v(' will be detailed in the next chapter "Names and name tables".')]),s("p",[s("code",{pre:!0},[e._v("ifnone")]),e._v(" is the value when a key does not have an attached value, its default is "),s("code",{pre:!0},[e._v("nil")]),e._v(". "),s("code",{pre:!0},[e._v("iter_lev")]),e._v(" is to make the hashtable reentrant (multithread safe).")]),s("h3",{attrs:{id:"struct-rfile"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#struct-rfile"}},[e._v("¶")]),e._v(" "),s("code",{pre:!0},[e._v("struct RFile")])]),s("p",[s("code",{pre:!0},[e._v("struct RFile")]),e._v(" is a structure for instances of the built-in IO class and its subclasses.")]),s("p",[e._v("▼ "),s("code",{pre:!0},[e._v("struct RFile")])]),s("pre",{pre:!0},[s("code",{pre:!0,attrs:{"v-pre":""}},[e._v(" 348  struct RFile {\n 349      struct RBasic basic;\n 350      struct OpenFile *fptr;\n 351  };\n\n(ruby.h)\n")])]),s("p",[e._v("▼ "),s("code",{pre:!0},[e._v("OpenFile")])]),s("pre",{pre:!0},[s("code",{pre:!0,attrs:{"v-pre":""}},[e._v("  19  typedef struct OpenFile {\n  20      FILE *f;                    /* stdio ptr for read/write */\n  21      FILE *f2;                   /* additional ptr for rw pipes */\n  22      int mode;                   /* mode flags */\n  23      int pid;                    /* child's pid (for pipes) */\n  24      int lineno;                 /* number of lines read */\n  25      char *path;                 /* pathname for file */\n  26      void (*finalize) _((struct OpenFile*)); /* finalize proc */\n  27  } OpenFile;\n\n(rubyio.h)\n")])]),s("p",[e._v("All members have been transferred in "),s("code",{pre:!0},[e._v("struct OpenFile")]),e._v(". As there aren't many instances of "),s("code",{pre:!0},[e._v("IO")]),e._v(" objects, it's OK to do it like this. The purpose of each member is written in the comments. Basically, it's a wrapper around C's "),s("code",{pre:!0},[e._v("stdio")]),e._v(".")]),s("h3",{attrs:{id:"struct-rdata"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#struct-rdata"}},[e._v("¶")]),e._v(" "),s("code",{pre:!0},[e._v("struct RData")])]),s("p",[s("code",{pre:!0},[e._v("struct RData")]),e._v(" has a different tenor from what we saw before. It is the structure for implementation of extension libraries.")]),s("p",[e._v("Of course structures for classes created in extension libraries as necessary, but as the types of these structures depend of the created class, it's impossible to know their size or structure in advance. That's why a \"structure for managing a pointer to a user defined structure\" has been created on "),s("code",{pre:!0},[e._v("ruby")]),e._v("'s side to manage this. This structure is "),s("code",{pre:!0},[e._v("struct RData")]),e._v(".")]),s("p",[e._v("▼ "),s("code",{pre:!0},[e._v("struct RData")])]),s("pre",{pre:!0},[s("code",{pre:!0,attrs:{"v-pre":""}},[e._v(" 353  struct RData {\n 354      struct RBasic basic;\n 355      void (*dmark) _((void*));\n 356      void (*dfree) _((void*));\n 357      void *data;\n 358  };\n\n(ruby.h)\n")])]),s("p",[s("code",{pre:!0},[e._v("data")]),e._v(" is a pointer to the user defined structure, "),s("code",{pre:!0},[e._v("dfree")]),e._v(" is the function used to free this structure, and "),s("code",{pre:!0},[e._v("dmark")]),e._v(' is the function for when the "mark" of the mark and sweep occurs.')]),s("p",[e._v("Because explaining "),s("code",{pre:!0},[e._v("struct RData")]),e._v(" is still too complicated, for the time being let's just look at its representation (figure 8). You'll read a detailed explanation of its members in chapter 5 \"Garbage collection\" where there'll be presented once again.")]),s("p",[s("img",{attrs:{src:r("1f8f"),alt:"Representation of "}})])])}],o=r("2877"),n={},i=Object(o["a"])(n,s,a,!1,null,null,null);t["default"]=i.exports},"1f8f":function(e,t,r){e.exports=r.p+"img/ch_object_rdata.7aad913b.png"},"570c":function(e,t,r){e.exports=r.p+"img/ch_object_string.8a85d5c1.png"},"76ea":function(e,t,r){e.exports=r.p+"img/ch_object_rbasic.db1c35ad.png"},a283:function(e,t,r){e.exports=r.p+"img/ch_object_value.5d54b879.png"},aa7c:function(e,t,r){e.exports=r.p+"img/ch_object_classtree.e35c06c4.png"},b054:function(e,t,r){e.exports=r.p+"img/ch_object_givtable.e2abfe66.png"},b6cb:function(e,t,r){e.exports=r.p+"img/ch_object_flags.9d81ccf4.png"},f61d:function(e,t,r){e.exports=r.p+"img/ch_object_class.edd73108.png"}}]);
//# sourceMappingURL=chunk-531a7aa0.dcf3ca51.js.map